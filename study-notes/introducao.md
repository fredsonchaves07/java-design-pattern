# Introdução a padrões de projetos

- Os padrões resolvem problemas específicos e tornam os projetos orientados a objetos mais flexíveis e, em última instância, reutilizáveis
- Em geral, o padrão tem quatro elementos essenciais
  - O nome padrão: é uma referência que podemos usar para descrever um problema de projeto, suas soluções e consequências em uma ou duas palavras. Dar nome a um padrão aumenta imediatamente o nosso vocabulário de projeto. Isso nos permite projetar em um nível mais alto de abstração
  - O problema: descreve em que situação aplicar o padrão. Explica o problema e seu contexto
  - A solução: descreve os elementos que compoem o padrão de projeto, seus relacionamentos, suas responsabilidades e colaborações
  - As consequências: são os resultados e análises das vantagens e desvantagens (trade-offs) da aplicação do padrão. 
- Padrões de projeto são descrições de objetos e classes comunicantes que precisam ser personalizadas para resolver um problema geral de projeto num contexto particular

## Projetando mudanças

- Um projeto que não leva em consideração a possibilidade de mudanças está sujeito ao risco de um agrnade reformulação no futuro. Essas mudanças podem envolver redefinições e reimplementações de classes, modificação de clientes e retestagem do sistema
- Os padrões de projjeto ajudam a evitar esses problemas ao garantirem que o sistema possa mudar segundo maneiras específicas
- Algumas causas comuns de refomulação de projeto, junto com o padrão que as tratam
  1. Criando um objeto pela especificação explícita de uma classe: Especificar um nome de uma classe quando você cria um objeto fz com que se comprometa com uma implementação em particular, em vez de se comprometer com uma determinada interface. Este compromisso pode complicar futuras mudanças. Para evitá-lo, crie objetos indiretamente. Padrões de projeto: Abstract factory, Factory method, Prototype
  2. Dependênca de operações específicas: Quando você especifica uma operção em particular, se compromete com uma determinada maneira de atender a uma solicitação. Evitando solicitações codificadas inflexivelmente (hard-coded), você torna mais fácil mudar a maneira como uma solicitação é atendida, tanto em tempo de compilação como o tempo de execução. Padrões de projeto: Chain of responsibility, Command
  3. Dependência da plataforma de hardware e software: As interfaces externas do sistema operacional e as API são diferentes para diferentes plataformas de hardware e software. O software que dependede uma plataforma específica será mais difícil de portar para outras plataformas. pode ser até mesmo difícil mante-lo atualizado para sua plataforma nativa. Portanto, é importante projetar o seu sistema para limitar suas dependências de plataformas. Padrões de projeto: Abstracty Factory, Bridge
  4. Dependência de representações ou implementações de objetos: Clientes que precisam saber como um objeto é representado, armazenado, localizado ou implementado podem necessitar ser alterados quando esse objeto muda. Ocultar essas informações dos clientes evita a propagação de mudança em cadeia. Padrões de projeto: Abstract Factory, Bridge, Memento, Proxy
  5. Dependência algorítmicas: Os algoritmos são frequentemente estendidos, otimizados e subsituídos durante o desenvolvimento e reutilização. Os objetos que dependem de algoritmos terão que mudar quando o algoritmo mudar. Portanto os algoritmos que provavelmente mudarão deveriam ser isolados. Padrões de projeto: Builder, Iterator, Strategy, Template, Method, Visitor
  6. Acoplamento forte: Classes que são fortemente acopladas são difíceis de reutilizar isoladamente, uma vez que dependem umas das outras. O acoplamento forte leva a sistemas monolíticos, nos quais você não pode mudar ou remover uma classe em compreender e mudar muitas outras classes. Os padrões de projeto usam técnicas como acoplamento abstrato e projeto em camadas para obter sistemas fracamente acoplados. Padrões de projeto: Abstract factory, Bridge, Chain of Responsibility, Command, Façade, Mediator, Observer
  7. Estendendo a funcionalidade pelo uso de subclasses: A composição de objetos, em geral, e a delegação, em particular, fornecem alternativas flexíveis à herança para combinação de comportamentos. Muitos padrõesde projeto produzem arquiteturas (design) nas quais você pode introduzir uma funcionalidade customizada smplesmente pela definição de uma subclasse e pela composição de suas instâncias com as existentes. Padrões de projeto: Bridge, Chain of responsibility, Composite, Decorator, Observer, Strategy
  8. Incapacidade para alterar classes de modo conveniente: Algumas vezes voc? tem que modificar uma classe que não pode ser convenientemente modificada. Talvez necessite do código fonte e não disponha do mesmo. Ou, talvez, qualquer mudança possa requerer a modificação de muitas subclasses existentes. Padrões de projeto oferencem maneiras para modificação de classes em tais circustãncias. padrões d eprojeto: Adapter, Decorator, Visitor